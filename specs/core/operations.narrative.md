# Operations

## Intent

Все операции над заметками. Использует vault как источник данных. Это бизнес-логика без привязки к CLI — чистые Python-функции/класс, которые можно вызывать и программно.

### CRUD операции:

1. **create(name, content?, frontmatter?)** — создать новую заметку в корне vault. Если заметка с таким именем уже существует — ошибка. Опционально: начальный frontmatter, содержимое body.

2. **read(name)** — вернуть содержимое заметки (полный текст: frontmatter + body).

3. **append(name, text)** — добавить текст в конец заметки. Автоматически добавляет `\n\n` перед новым текстом. Частый кейс: daily notes, логи.

4. **update(name, content)** — полностью заменить body заметки, сохранив frontmatter. Частый кейс: AI-агент переписал текст заметки.

5. **delete(name, dry_run=False)** — при удалении: обновить все `[[name]]` → `[[name (deleted)]]` во всех живых заметках vault, затем переместить файл в `.trash/` внутри vault. При dry_run — показать что будет сделано без выполнения.

### Переименование:

6. **rename(old_name, new_name, dry_run=False)** — переименовать файл заметки И обновить все `[[old_name]]` ссылки во всех живых заметках vault (исключая `.trash/`) на `[[new_name]]`.

### Frontmatter:

7. **frontmatter_get(name)** — вернуть frontmatter заметки как dict.
8. **frontmatter_set(name, key, value)** — установить/изменить top-level поле frontmatter. Не трогать body. Вложенные ключи не поддерживаем — только top-level. Теги вида `vc/project` — это просто строки в списке `tags`.

### Поиск:

9. **search(query, mode)** — поиск заметок. Режимы:
   - `name` — точное совпадение имени
   - `name_partial` — часть имени (case-insensitive substring)
   - `content` — поиск по содержимому body (case-insensitive substring, аналог SQL ILIKE '%text%')
   - `tag` — поиск по тегам (из frontmatter `tags:`)

   Результат: список заметок с полным путём к файлу (для программной обработки).

### Связи:

10. **links(name, direction)** — получить список заметок, связанных с данной:
   - `outgoing` — на кого ссылается эта заметка (`[[...]]` внутри неё)
   - `incoming` — кто ссылается на эту заметку (backlinks)
   - `both` — оба направления

### Batch:

11. Операции rename и delete поддерживают batch-режим: JSON файл или stdin.
    - Batch rename: JSON формат `{"old_name": "new_name", ...}`
    - Batch delete: JSON формат `["name1", "name2", ...]`

### Текстовые операции (partial editing):

12. **replace(name, old_text, new_text, all=False)** — частичная замена текста в заметке. Заменяет первое вхождение `old_text` на `new_text`. Флаг `all` — заменить все вхождения. Ошибка если `old_text` не найден. Frontmatter не затрагивается — замена только в body.

13. **insert(name, text, before=None, after=None)** — вставка текста перед или после паттерна. Ровно один из `before`/`after` должен быть указан. Ошибка если паттерн не найден. Frontmatter не затрагивается.

14. **append_section(name, section, text)** — добавить текст в конец указанной секции. Секция определяется по заголовку markdown (например `## Open Questions`). Текст вставляется перед следующим заголовком того же или более высокого уровня. Ошибка если секция не найдена.

15. **read_section(name, section)** — вернуть содержимое секции. Секция определяется по заголовку, контент — от заголовка до следующего заголовка того же или более высокого уровня (или до конца файла).

## Clarifications

Q1: При rename — если заметка B содержит `[[A]]` и мы переименовываем A → A_new, нужно ли обновлять ссылки внутри `.trash/`? Или только в "живых" заметках?
A1: Только в живых.

Q2: При delete — нужно ли также удалять/обновлять ссылки на удалённую заметку в других заметках?
A2: Да. При удалении заметки `note` — обновить все `[[note]]` → `[[note (deleted)]]` во всех живых заметках, затем переместить файл в `.trash/`. Так сразу видно, что ссылка ведёт на удалённую заметку.

Q3: Frontmatter set — поддерживаем ли вложенные ключи (например вложенные YAML-словари)?
A3: Нет, только top-level ключи. Вложенные теги типа `vc/project` — это строки в списке `tags`, не вложенные YAML-структуры.

Q4: Search по контенту — нужен ли regex, или достаточно простого case-insensitive substring?
A4: Простой case-insensitive substring (аналог ILIKE '%text%'). Достаточно для первой версии.

Q5: Batch rename — формат файла?
A5: JSON. Для rename: `{"old_name": "new_name", ...}`. Для delete: `["name1", "name2", ...]`.

Q6: Search по тегам — у тебя есть вложенные теги: `vc` и `vc/project`. Если ищем по тегу `vc`, должны ли находиться заметки с тегом `vc/project`?
A6: Да, иерархический поиск. `vc` находит и `vc/project`.

Q7: replace — "сохраняет frontmatter без изменений" — подразумевается что замена происходит только в body? Если `old_text` встречается и во frontmatter и в body — игнорируем frontmatter?
A7: Да, замена только в body. Frontmatter игнорируем — это защита от случайного повреждения метаданных.

Q8: insert — паттерн `after: "## Section Header"` — ищем точное совпадение строки или строку содержащую паттерн? Например `after: "## Budget"` найдёт строку `## Budget Overview`?
A8: Точное совпадение строки (trim whitespace). `## Budget` НЕ найдёт `## Budget Overview`. Если нужен partial match — пусть будет отдельный флаг `--contains`, но по умолчанию exact.

Q9: insert — если паттерн встречается несколько раз, вставляем после/перед первым вхождением?
A9: Да, первое вхождение. Флаг `--all` для всех вхождений (low priority, можно не делать в v1).

Q10: append_section / read_section — уровень заголовка определяется количеством `#`. Если секция `## Budget`, то подсекция `### Details` внутри неё — это часть секции Budget? Т.е. секция заканчивается на заголовке того же или более высокого уровня (`#` или `##`), но не на подзаголовке (`###`)?
A10: Да, именно так. `## Budget` включает всё до следующего `#` или `##`, подсекции `###` и ниже — часть секции.

Q11: read_section — возвращает контент с заголовком секции или только содержимое после заголовка?
A11: Только содержимое после заголовка (без самого `## Budget`). Заголовок я и так знаю — мне нужен контент.

Q12: replace/insert — если заметка не имеет frontmatter (чистый markdown без `---`), операции работают с полным содержимым файла?
A12: Да, весь файл = body. Без frontmatter — работаем со всем содержимым.

Q13: JSON output (`--output json`) — это к CLI слою, не к Operations. Нужен ли единый формат для всех команд CLI или только для новых?
A13: Единый формат для всех. Минимум: `{"success": bool, "data": any, "error": string|null}`. Для read операций `data` = контент, для write операций `data` = `{"modified": true, "matches": 1}` или подобное.

Status: resolved
