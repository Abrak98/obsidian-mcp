# Vault

## Intent

Ядро системы — доступ к Obsidian vault. Компонент отвечает за:

1. **Конфигурация пути к vault**: путь задаётся через env var `OBSIDIAN_VAULT_PATH` (fallback на `--vault-path` CLI флаг). Vault — это директория с `.md` файлами. На WSL путь вида `/mnt/c/Users/<username>/...`, на Windows — `C:\Users\<username>\...`. Работаем всегда с одним vault.

2. **Сканирование vault**: обход всех `.md` файлов в корне vault. Структура плоская — папок нет, все заметки лежат в корне. Пропускать `.obsidian/`, `.trash/` и прочие dot-директории.

3. **Парсинг заметки**: каждая заметка = YAML frontmatter (`---` delimiters) + markdown body. Из body извлекаются `[[wikilinks]]` (только формат `[[note]]`, без `[[note|alias]]` и `[[note#heading]]`). Парсинг frontmatter через PyYAML/python-frontmatter. Из frontmatter парсятся теги (`tags:` поле) для последующего поиска.

4. **Индекс заметок**: в памяти хранится маппинг имя заметки → полный путь, граф связей (какая заметка ссылается на какую), и теги каждой заметки. Индекс строится при первом обращении и кэшируется in-memory. При cache miss (запрошенная заметка не найдена в индексе) — автоматический rescan vault и повторная попытка. Это критично для long-running процессов (MCP-сервер), где заметки создаются извне (через Obsidian UI) после построения индекса. Кэширование на диск — не в первой версии, добавим если будет медленно.

5. **Резолв имени**: по имени заметки (без `.md`) вернуть полный путь к файлу. Структура плоская, дубликатов имён нет.

Используется остальными компонентами (operations, cli) как единственный способ доступа к vault.

## Clarifications

Q1: Нужно ли поддерживать несколько vault одновременно, или всегда работаем с одним?
A1: С одним.

Q2: Заметки могут быть вложены в поддиректории (папки внутри vault). Нужно ли хранить информацию о папке заметки, или только имя + полный путь достаточно?
A2: Строго плоский подход. Никаких папок в vault, все заметки в корне.

Q3: Wikilinks бывают нескольких видов: `[[note]]`, `[[note|alias]]`, `[[note#heading]]`, `[[note#heading|alias]]`. Какие варианты поддерживаем в первой версии?
A3: Только `[[note]]`. Алиасы добавляются в frontmatter (поле `aliases`).

Q4: Нужно ли при сканировании парсить теги (формат `tags:` в frontmatter), чтобы потом по ним искать?
A4: Да, vault парсит теги из frontmatter при сканировании. Operations использует их для поиска по тегам.

Q5: Vault на Windows-диске через WSL может быть медленным при рекурсивном обходе. Стоит ли сделать кэширование индекса на диск?
A5: Начинаем без кэширования на диск, in-memory на время вызова. Если будет медленно — добавим, следя за консистентностью.

Q6: При cache miss (заметка не в индексе) — rescan vault и retry. Это единственный сценарий автоматического rescan, или есть другие (например, list_notes тоже должен rescannуть по таймауту)?
A6: Только при cache miss в get_note. list_notes возвращает что есть в кэше — если нужен свежий список, вызывающий код делает refresh() явно.

Status: resolved
